# [网络]()

## DNS服务器，域名

- 直接访问域名是无法访问到机器

- 要域名和IP地址形成对应关系

- 在互联网建立的时候，有13太总的DNS服务器

- 如果计算机不知道域名对应的IP的，会先问路由器，如果路由器认识这个域名就会返回一个IP

  然后计算机访问这个IP，如果路由器不认识，就会问上层的路由器。

  如果问道城市的这个级别的路由器，还没有对应的IP，就会找DNS服务器。

  如果DNS服务器不认识这个域名，继续向上级DNS服务器查找， 如果找到了会一层层的缓存这个IP，下次就不用访问的太远

- 当向浏览器的地址栏中输入一个url按回车之后，网络中都会发生什么？

  - 比如输入 `123.xyz`
    1. 看游览器缓存
    2. 看本机host
    3. 家里的路由器
    4. 上级路由器，城市的DNS服务器
    5. 继续上级DNS服务器
    6. 全局的DNS服务器
    7. 找到后一层层缓存

## 五层网络模型

1. **应用层**

   - HTTP协议
     - HTTP协议分为两个部分
       - 请求：Request
         - 请求方式 路径 协议版本
         - 请求方法：GET, POST (常见)
       - 响应：Response
   - DNS协议

2. **运输层**

   - TCP协议
   - UDP协议

3. **网络层**

   - IP地址

4. **数据链路层**

5. **物理层**

   - 二进制 0001101010

   - 低电平
   - 高电平

6. **物理层协议-->数据链路层协议-->TCP/IP协议(对方的IP，自己的IP，对方的端口)->HTTP协议->数据**

7. **HTTP协议是明文传输**

   

### GET和POST的区别

1. 是基于什么前提的？如果什么前提都没有，不使用任何规范，只考虑语法和理论上的HTTP协议

   - GEThePOST几乎没有什么区别，只有名字的不一样

2. 如果是基于RFC规范的

   1. 理论上：GET和POST具有相同的语法，但是有不同的语义，GET是用来获取数据的，POSt是用来发送数据的，其他方面没有什么区别
   2. 实现上的：各种游览器，就是这个规范的实现者。
      - 常见的那些不同
        1. GET的数据在URL是可见。POST请求不显示在URL中。
        2. GET对长度是有限制的，POST请求长度是无限的。
        3. GET请求的数据可以收藏为书签，POST请求到的数据不可以收藏为书签
        4. GET请求后，按后退按钮，刷新按钮无影响，POST数据会被重新提交
        5. GET编码类型：`application/x-www.form-url`,POST的编码类型：有很多种。`encodeapplication/x-www-form-urlencoded`    `multipart/form-data`
        6. GET历史参数会被保留在游览器里，POST不会保存在游览器中
        7. GET只允许ASCLL   POST没有编码限制，允许发二进制
        8. GET与POST相比，GET安全性较差，因为所发的数据是URL的一部分

   

### 发送请求

1. 在游览器中直接输入地址
2. `location.href = '网址'` 可以发出请求，但是页面会发生跳转
3. 带有src属性的标签  请求是可以发出的，服务的是可以处理的也是可以返回，但返回之后，能否被应用，还要看游览器
4. 带有href的标签  请求是可以发出的，服务的是可以处理的也是可以返回，但返回之后，能否被应用，还要看游览器
5. 带有action的标签
6. ajax

### AJAX

```javascript
const xhr = new XMLHttpRequest();
xhr.open("GET",'www.baidu.com',false); // false 代表同步加载，会阻塞
xhr.onreadystatechange=function(){
 // readyState == 4说明请求已完成
 if(xhr.readyState==4){  
 	if(xhr.status==200 || xhr.status==304){
         console.log(xhr.responseText);
        }
     }
  };
xhr.send();
```

服务器的状态码 [](https://www.runoob.com/http/http-status-codes.html)

### 跨域

​	**<u>协议 域名 端口 只要有一个不一样就是跨域</u>**

- **跨域的行为发生在哪里？**
  - **即使跨域的请求也是可以发出的**
  - **服务器端也是也可以接收的**
  - **服务器端也是可以正常处理的**
  - **服务器端也是可以正常处理数据的**
  - **游览器也能收到这些数据**
  - **接收到之后，发现当前页面的域和请求的域不同，判断为跨域，就不会把数据返回给我们的代码**

1. src属性的请求的资源是可以跨域的，href属性的请求的资源大部分是可以跨域的
2. 后端接口的数据 会跨域
3. 其他域的cookie 会跨域
4. 其他域的缓存    会跨域

#### 解决跨域问题

1.  后端配合我们进行跨域
   1. JSONP
   2. 后端设置Access-Control-Allow-Origin属性以支持跨域 (CORS)

2. 后端不配合跨域
   1. iframe 只能显示，不能控制
   2. 通过后端代理 （自己的后端）

### JSONP原理

script标签虽然可以发送请求不受跨域，但是返回的内容，会作为js代码执行

1. 生成一个script标签
2. 生成一个callback函数
3. 将script.src设置成要请求的接口，将callback拼接在后面
4. 后端接收到请求，开始准备数据
5. 将准备的数据用callback的值用括号包裹起来,加入callback的名字就是callback  callback( {a: 1, b: 2} )
6. 游览器接收到内容，会当作js代码执行
7. 在callback函数的参数里就是返回的数据